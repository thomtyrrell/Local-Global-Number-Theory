# To construct examples with the correct local/global conditions for our experiments, we run 
# quadClassNumber(6) to obtain a prime p, run specialPrimes(p) to obtain a prime q, and then we consider
# X : y^2 = qx^6 - p.  In the languague of g2SplitJacobian(â€¦), E is the elliptic curve Y^2 = X^3 -p*q^2, 
# d=1, a=0.  The map from X to E is given by (X=qx^2,Y=qy). The map to the other factor Y^2 = X^3 + p^2*q 
# of X's Jacobian is given by (X=-p/x^2, Y=py/x^3).  It follows (proof to come) that such a curve has no 
# rational points.
	
# By the Weil Conjectures, this curve is guaranteed to have local solutions for all p >= 17.  We
# combine Quadratic Reciprocity and analysis at small primes relative to p in order to choose q so that 
# the curve has solutions at all primes.

# The methods below aid in generating examples.

# quadClassNumber(h): with optional arguments
# Returns a list of primes p <= U such that the class number of the (imaginary) quadratic extension
# generated by \sqrt{-p} is h.  By default only one value of p is returned.  For more examples,
# specify a value of k > 1.  
def quadClassNumber(h,k=1,U=100):
	primes = [];
	for p in Primes():
		if len(primes) == k or p > U:
			break;
		K = QuadraticField(-p);
		if K.class_number() == h:
			primes.append(p);
	return primes;

# specialPrimes(p): with optional arguments
# Given a prime p, returns at most k unramified primes q <= U which factor in the (imaginary) quadratic 
# extension generated by sqrt(-p) as a product of non-principal ideals.
#
# The loop over the sets S1 and S2 ensures local solubility.  It is exhaustive.
def specialPrimes(p,k=10,U=100, S1={3,7}, S2={5,13}):
	K = QuadraticField(-p);
	primes = [];
	for q in Primes():
		if q<5 or q==p: #we ignore 2 (the oddest prime), 3 (usual prime of bad reduction) and p (the obvious ramified prime)
			continue;
		elif len(primes) == k or q > U:
			break;
		else:
			for l in S1:
				if not(Mod(q-p,l).is_square()):
					break;
					
			for l in S2:
				if not(Mod(q-p,l).is_square() or Mod(-q-p,l).is_square()):
					break;
					
			for x in range(0,11):
				if Mod(q*x-p,11).is_square() or Mod(-q*x-p,11).is_square():
					P = K.primes_above(q); #there are 1 or 2 prime ideals contained in P.  
					if len(P)==2 and not(P[0].is_principal()):
						primes.append(q);
						break;
	return primes;  

# Write a function that outputs a pair (p,q) of primes such that the curve X: y^2 = qx^6 - p has no 
# rational solutions, and solutions modulo all primes.	

# Following Bremner, if q is chosen using the specialPrimes(p) method, then assuming the class number
# of K divides 6 non-trivially, X cannot have a rational point.

# The only remaining question would be local points, and for l >= 17, l not p,q, we are guaranteed local 
# points.  The remaining cases:

# l=2:  (0,1)
# l=3:  q-p is a square mod 3
# l=5: +/-q - p is a square mod 5
# l=7:  q-p is a square mod 7
# l=11: +/-qx - p is a square mod 11.
# l=13:  +/-q-p is a square mod 13
# l=infinity:  y=0
# l=q:  q is chosen so that y^2 + p is reducible mod q.
# l=p:  (0,0)

# We have expanded the specialPrimes(p) method to incorporate these conditions in its search. 

# admissiblePairs(...) will output at most k^2 pairs (p,q) of primes such that the genus 2 curve y^2 = qx^6 - p has no 
# rational points but local points at all places.  The associated Jacobian is splitJacobian(y^2=x^3-p*q^2,0,1/q)
def admissiblePairs(k=1, U=100):
	p_ = quadClassNumber(6,k,U);
	for p in p_:
		q_ = specialPrimes(p,k,U);
		for q in q_:
			print (p,q);	
			
# The Bremner curves are all (2,2)-split curves, so the above point-counting methods apply. 